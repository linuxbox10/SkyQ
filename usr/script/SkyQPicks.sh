#!/bin/bash
# SCRIPT: SkyQPicks.sh
#
# Pick random entries from image lists generated by SkyQScrape.sh
# and download them as images for SkyQ show bouquet screen.
#
# NOTE: 1. If you want this script to be the only one needing to be scheduled
#          then you can have it initiate the input file downloads by uncommenting
#          $sources_maxage. Doing so will have this script call SkyQScrape.sh
#          if it finds any image list file OLDER than the value specified (in mins)
#          e.g. This script could be set to run every 15m, but SkyQScrape.sh would
#          only be called when an image list was >12hrs(=720mins) old (default).
#       2. If files containing image lists are hosted online (a possibility)
#          then uncomment the '$sources_server' variable and define the server
#          base-URL (i.e. the path to the files) in it in order to
#          download the lists from a server. In this case script SkyQScrape.sh
#          no longer needs to be run locally (contents overwritten anyway).
# TODO: .  Although /usr/script/scrapes seems to have become the facto standard
#          location for the image URL lists this doesn't fit with the purpose
#          of this dir. A dir within the '/usr/share/...' structure, ideally
#          within skin folder's 'Toppicks' dir itself is preferable.
# UNDO??   TOPPICKS IMAGE PICONS ARE HARDCODED IN THE SKYQ SKIN... THIS MEANS:
#       .  RANDOMISATION OF IMAGE SOURCE FILES HAS BEEN REMOVED BY RESTRICTING
#          ASSIGNED 'CATEGORY' RANGES TO SINGLE POSSIBLE VALUE MATCHING PICON.
#       .  LOGIC WHICH REPLACES TOPPICKS PICONS WITH THOSE OF THE RANDOM SOURCE
#          INPUT FILE HAS BEEN COMMENTED OUT.
 
# UNCOMMENT TO AUTOMATICALLY DOWNLOAD NEW IMAGE LISTS IF THEY'RE <X> MINUTES OLD
sources_maxage="720"
# UNCOMMENT TO GET IMAGE LISTS FROM SERVER INSTEAD OF FROM SCRIPT SKYQSCRAPE.SH
#sources_server="http://www.example.com/toppicks/lists/"

workdir="/usr/script/scrapes"		# PREFER: /usr/share/enigma2/SkyQ/Toppicks/scrapes
piconbase="/usr/share/enigma2/SkyQ/Toppicks/picons-base/"
piconpath="/usr/share/enigma2/SkyQ/Toppicks/picons/"
screenpath="/usr/share/enigma2/SkyQ/Toppicks"
scraper="/usr/script/SkyQScrape.sh"
image_lists="new.txt store.txt premieres.txt living.txt one.txt atlantic.txt cinema.txt sports.txt"

if [ ! -d "${workdir}" ]; then
  mkdir -p "${workdir}" || exit 1
fi

# If an image list is missing or out of date then download it ($SOURCES_MAXAGE MUST BE UNCOMMENTED TO ENABLE THIS)
if [ -n "${sources_maxage}" ]; then
  for image_source in ${image_lists}; do
    if [ ! -s "${workdir}/${image_source}" ] || [ $(find "${workdir}" -name "${image_source}" -mmin +"${sources_maxage}") ]; then
      if [ -n "${sources_server}" ]; then
        wget -q "${sources_server}/${image_source}" -O "${workdir}/${image_source}"
      else
        outofdate="${image_source} ${outofdate}"
      fi
    fi
  done
  if [ -n "${outofdate}" ]; then
    /bin/bash ${scraper} ${outofdate}
  fi
fi

# Configure each toppicks<x> screen
for image_no in 1 2 3 4 5 6 7 8; do
  # Set the toppicks image size and define allowed categories
  case ${image_no} in
    1) resize="w=845&h=475&mode=crop"; min_category="1"; max_category="1" ;;
    2) resize="w=105&h=158&mode=crop";  min_category="3"; max_category="3" ;;
    3) resize="w=278&h=158&mode=crop"; min_category="5"; max_category="5" ;;
    4) resize="w=278&h=158&mode=crop"; min_category="7"; max_category="7" ;;
    5) resize="w=278&h=158&mode=crop"; min_category="6"; max_category="6" ;;
    6) resize="w=278&h=158&mode=crop"; min_category="4"; max_category="4" ;;
    7) resize="w=105&h=158&mode=crop";  min_category="2"; max_category="2" ;;
    8) resize="w=278&h=158&mode=crop"; min_category="8"; max_category="8" ;;
  esac

  # Assign a random category to the image from within the defined range (inclusive)
  category="$(( ( RANDOM % ((1 + max_category - min_category)) ) + min_category ))"

  # Set the input txt file and picon png based on the category assigned
  case ${category} in
    1)  image_source="new.txt";       image_picon="premiere.png" ;;
    2)  image_source="store.txt";     image_picon="store.png" ;;
    3)  image_source="premieres.txt"; image_picon="cinema.png" ;;
    4)  image_source="cinema.txt";    image_picon="cinema.png" ;; # More specific picon may be assigned @106
    5)  image_source="atlantic.txt";  image_picon="atlantic.png" ;;
    6)  image_source="living.txt";    image_picon="living.png" ;;
    7)  image_source="one.txt";       image_picon="one.png" ;;
    8)  image_source="sports.txt";    image_picon="sports.png" ;;
  esac

  # If the input file is valid (and has entries in it) then pick an image URL at random from it
  if [ -s "${workdir}/${image_source}" ]; then
    echo "Image ${image_no} updating from random entry in ${image_source}"
    all_lc=$(wc -l < "${workdir}/${image_source}")
    linenum=$(( ( RANDOM % ${all_lc} ) + 1 ))
    link=$(sed -n ${linenum}p "${workdir}/${image_source}")

    # Download the image at the chosen URL to a temp file
    if wget -q "${link}?${resize}&format=png" -O "${screenpath}/toppicks${image_no}.$$"; then

      # If image downloaded successfully, replace the current toppicks image
      mv "${screenpath}/toppicks${image_no}.$$" "${screenpath}/toppicks${image_no}.png"

#      # Before updating picon, see if we're using a 'cinema.txt' link. If we are, then get the
#      # WhatsOn category from the URL and see if a matching picon file <category>.png is present.
#      # To see a list of all possible categories you need to cover, run:
#      #  awk -F'/' '{print tolower($(NF-1))}' cinema.txt | sed 's/whatsnew/premiere/g' | sort -u
#      if [ "${image_source}" == "cinema.txt" ]; then
#        subcat=$(echo "${link}" | awk -F'/' '{print tolower($(NF-1))}' | sed 's/whatsnew/premiere/g')
#        if [ -s "${piconbase}/${subcat}.png" ]; then
#          image_picon="${subcat}.png"
#        fi
#      fi
#
#      # Update toppicks picon if it exists and is different to the one currently in place
#      if [ -s "${piconbase}/${image_picon}.png" ]; then
#        diff -q "${piconbase}/${image_picon}" "${piconpath}/picon${image_no}.png" >& /dev/null || \
#             cp "${piconbase}/${image_picon}" "${piconpath}/picon${image_no}.png" >& /dev/null
#      else
#        echo "Image picon ${image_picon}.png not found. Existing picon left in place." >&2
#      fi

    # If the image retrieval failed then don't update anything (just remove temp file)
    else
      echo "Update of image ${image_no} failed, leaving old image and picon in place." >&2
      rm "${screenpath}/toppicks${image_no}.$$" >& /dev/null
    fi

  # If the image source file doesn't exist or was empty then do nothing.
  else
    echo "Image ${image_no} not updated. ${image_source} not found." >&2
  fi

 done

exit 0